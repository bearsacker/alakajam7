include window
include title

global const int MAX_LIFES = 5

global int score = 0
global int lifes = MAX_LIFES

global List markers = List:new()
global Kraken kraken = Kraken:new()
global List boats = List:new()
global List rocks = List:new()
List:add(rocks, Rock:new(ROCK_SPRITE_1, 0, 3, 0))
List:add(rocks, Rock:new(ROCK_SPRITE_2, 3, 4, 2))
List:add(rocks, Rock:new(ROCK_SPRITE_1, 10, 4, 1))
List:add(rocks, Rock:new(ROCK_SPRITE_2, 13, 6, 0))
List:add(rocks, Rock:new(ROCK_SPRITE_3, 14, 5, 3))
List:add(rocks, Rock:new(ROCK_SPRITE_1, 7, 7, 2))
List:add(rocks, Rock:new(ROCK_SPRITE_2, 8, 7, 2))
List:add(rocks, Rock:new(ROCK_SPRITE_3, 6, 7, 1))
List:add(rocks, Rock:new(ROCK_SPRITE_3, 9, 7, 2))

global int lastDisplay = time
global int lastUpdate = time

global const int DIRECTION_NONE = 0
global const int DIRECTION_FORWARD = 1
global const int DIRECTION_BACKWARD = 2
global int direction = DIRECTION_NONE

function resetGame() {
    List:clear(markers)
    List:clear(boats)
    kraken = Kraken:new()
    score = 0
    lifes = MAX_LIFES
}

function drawScene() {
    lastDisplay = time

    int mouseX = Input:getMouseX()
    int mouseY = Input:getMouseY()
    if mouseY > 0 && mouseY < (ZOOM * 64) {
        mouseY = (ZOOM * 64)
    }

    Graphics:clear()

    Graphics:drawSprite(SEA_SPRITE[seaCurrentFrame], 0, 0, 0, ZOOM)
    Graphics:drawSprite(SKY_SPRITE, 0, 0, 0, ZOOM)

    int i = 0
    while i < boats.size {
        Boat boat = List:get(boats, i)
        Graphics:drawSprite(boatSprite[boat.frame], ZOOM * boat.x, ZOOM * boat.y, 0, ZOOM)
        
        if time - lastUpdate > 100 {
            int boatState = Boat:update(boats.elements[i], mouseX, mouseY, direction)

            if boatState == BOAT_STATE_SAFE {
                List:remove(boats, i)
                List:add(markers, Marker:new(MARKER_TYPE_GAIN, boat.x, boat.y - 16))
                snd_action play MARKER_GAIN_SOUND null

                score++
            } else if boatState == BOAT_STATE_DESTROY {
                List:remove(boats, i)
                List:add(markers, Marker:new(MARKER_TYPE_LOSE, boat.x, boat.y - 16))
                snd_action play MARKER_LOSE_SOUND null

                lifes--
                if lifes < 0 {
                    lifes = 0
                }
            } else {
                i++
            }
        }
    }

    int i = 0
    while i < rocks.size {
        Rock:draw(rocks.elements[i])
        if time - lastUpdate > 100 {
            Rock:update(rocks.elements[i])
        }

        i++
    }

    Kraken:draw(kraken)
    if time - lastUpdate > 100 {
        Kraken:update(kraken, mouseX, mouseY, direction)
    }

    if mouseX > 0 && mouseY > 0 {
        if direction == DIRECTION_FORWARD || direction == DIRECTION_BACKWARD {
            Graphics:setColor(LIGHT_ON)
        } else {
            Graphics:setColor(LIGHT_OFF)
        }

        Graphics:drawLine(ZOOM * 128, ZOOM * 144, mouseX - 4, mouseY, 7)
        Graphics:drawLine(ZOOM * 128, ZOOM * 144, mouseX + 4, mouseY, 7)
    }

    Graphics:drawSprite(CLIFF_SPRITE, ZOOM * 104, ZOOM * 160, 0, ZOOM)
    Graphics:drawSprite(LIGHTHOUSE_SPRITE, ZOOM * 112, ZOOM * 126, 0, ZOOM)

    int i = 0
    while i < markers.size {
        Marker:draw(markers.elements[i])
        if time - lastUpdate > 100 {
            Marker:update(markers.elements[i])

            if Marker:isDead(markers.elements[i]) {
                List:remove(markers, i)
            } else {
                i++
            }
        } else {
            i++
        }
    }

    Graphics:drawText("LIFES " + lifes, ZOOM * 2, ZOOM * 2, ATASCII, ZOOM / 2)
    Graphics:drawText("SCORE " + score, ZOOM * (WIDTH - ("SCORE " + score).length * 8 - 2), ZOOM * 2, ATASCII, ZOOM / 2)

    Graphics:flush()
}

int waitBeforeBoat = 0
int waitBeforeKraken = 0

while true {
    if time - lastDisplay > 25 {
        drawScene()
    }

    if time - lastUpdate > 100 {
        Input:flush()
        if Input:isButtonPressed(1) {
            direction = DIRECTION_FORWARD
        } else if Input:isButtonPressed(3) {
            direction = DIRECTION_BACKWARD
        } else {
            direction = DIRECTION_NONE
        }

        if boats.size < MAX_BOATS && Random:rand(20) == 1 && waitBeforeBoat <= 0 {
            List:add(boats, Boat:new())
            waitBeforeBoat = 10
        }
        waitBeforeBoat -= 1

        if kraken.state == KRAKEN_STATE_IMMERSED && waitBeforeKraken <= 0 && score >= 5 && (score == 5 || Random:rand(50) == 1) {
            Kraken:incoming(kraken)
            waitBeforeKraken = 60
        }

        if kraken.state == KRAKEN_STATE_IMMERSED {
            waitBeforeKraken--
        }

        if lifes == 0 {
            include gameover
            resetGame()
        }

        seaCurrentFrame = (seaCurrentFrame + 1) % SEA_SPRITE.length
        lastUpdate = time
    }

    sleep 10
}
